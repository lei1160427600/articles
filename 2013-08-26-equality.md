---
title: Equality
author: Mattt Thompson
translator: Chester Liu
category: Objective-C
tags: nshipster
excerpt: "The concept of equality is a central point of debate and inquiry in philosophy and mathematics, with far-reaching implications for matters of ethics, justice, and public policy. It is the task of programmers to reconcile our logical and physical understanding of equality with the semantic domains we model."
excerpt: "在哲学和数学领域，相等的概念一直以来都是人们所争论和探寻的焦点，其所蕴含的深层含义更是延伸到道德，社会正义以及公共政策等诸多层面。对于程序员来说，在我们所建模的问题领域当中，协调好“相等”概念在逻辑上和实际意义上的理解，是一个很重要的任务。"
status:
    swift: n/a
---

The concept of equality is a central point of debate and inquiry in philosophy and mathematics, with far-reaching implications for matters of ethics, justice, and public policy.

在哲学和数学领域，相等的概念一直以来都是人们所争论和探寻的焦点，其所蕴含的深层含义更是延伸到道德，社会正义以及公共政策等诸多层面。

From an empiricist perspective of the universe, two objects are equal if they are indistinguishable from one another in measurable observations. On a human scale, egalitarians hold that individuals should be considered equal members of the societal, economic, political, and judicial systems they inhabit.

从经验主义的角度来看，当两个物体没办法通过观察来互相区分开的时候，这两个物体就是相等的。对于人类而已，信奉平等主义的人相信，所有人都应该被认为是平等的个体，在其所存在的社会，生态，政治和司法系统中得到平等的待遇。

It is the task of programmers to reconcile our logical and physical understanding of equality with the semantic domains we model. There is a subtlety to the question of equality, too often overlooked. Jumping into implementation without sufficient understanding of semantics can lead to unnecessary work that produces incorrect results. Though an understanding of the mathematical and logical system underpinning is equally essential to making things work as modeled.

对于程序员来说，在我们所建模的问题领域当中，协调好“相等”概念在逻辑上和实际意义上的理解，是一个很重要的任务。在处理相等的概念的时候，有些细微的问题经常会被忽略。在没有对于相等语义有着足够理解的情况下，就直接进行编码实现，往往会导致冗余的工作和错误的结果。对底层数学和逻辑系统的深层理解，和真正让模型工作起来同等重要，对于我们都是必不可少的。

While the temptation for all technical blog posts is to skim for headings and code samples, please take a few minutes to read and understand all of this. **Copying relevant-looking code verbatim without knowing why its there may lead to incorrect behavior**. With all seriousness, equality is one of those topics—in Objective-C in particular—where there is still [a great deal of confusion](http://stackoverflow.com/questions/254281/best-practices-for-overriding-isequal-and-hash).

尽管对于所有技术博文来说，我们最想做的就是扫一下标题然后去找示例代码，但是对这篇文章来说，请务必花几分钟时间来阅读和理解它。**在不懂得原理的情况下照搬那些看起来有关的代码可能会导致程序产生错误的行为**。不开玩笑，在 Objective-C 的领域，相等性是最容易[产生误解](http://stackoverflow.com/questions/254281/best-practices-for-overriding-isequal-and-hash)的话题之一。

## Equality & Identity

First and foremost, it is important to make a distinction between _equality_ and _identity_.

首先，我们要对于 _相等性_ 和 _本体性_ 进行一下区分。

Two objects may be _equal_ or _equivalent_ to one another, if they share a common set of observable properties. Yet, those two objects may still be thought to be _distinct_, each with their own _identity_. In programming, an object's identity is tied to its memory address.

当两个物体有一系列相同的可观测的属性时，两个物体可能是互相 _相等_ 或者 _等价_ 的。但这两个物体本身仍然是 _不同的_ ，它们各自有自己的 _本体_ 。 在编程中，一个对象的本体和它的内存地址是相关联的。

`NSObject` tests equality with another object with the method `isEqual:`. In its base implementation, an equality check is essentially a test for identity. Two `NSObject`s are considered equal if they point to the same memory address.

`NSObject` 使用 `isEqual:` 这个方法来测试和其他对象的相等性。在它的基类实现中，相等性检查本质上就是对本体性的检查。两个 `NSObject` 如果指向了同一个内存地址，那它们就被认为是相同的。

~~~{objective-c}
@implementation NSObject (Approximate)
- (BOOL)isEqual:(id)object {
  return self == object;
}
@end
~~~

For container classes like `NSArray`, `NSDictionary`, and `NSString`, the expected and indeed more useful behavior would be to do a deep equality comparison, to test that each member in the collection is equal.

对于 `NSArray`，`NSDictionary` 和 `NSString` 这种容器类来说，大家所期望的，同时也是更加有用的行为，应该是进行深层的相等性检查，对于集合中的每个成员都进行判断。

Subclasses of `NSObject` implementing their own `isEqual:` method are expected to do the following:

`NSObject` 的子类在实现它们自己的 `isEqual:` 方法时，应该完成下面的工作：

- Implement a new `isEqualTo__ClassName__:` method, which performs the meaningful value comparison.
- 实现一个新的 `isEqualTo__ClassName__` 方法，进行实际意义上的值的比较
- Override `isEqual:` to make class and object identity checks, falling back on the aforementioned value comparison method.
- 重载 `isEqual:` 方法进行类和对象的本体性检查，如果失败则回退到上面提到的值比较方法。
- Override `hash`, which will be described in the next section.
- 重载 `hash` 方法，在下一个部分会详细介绍

Here's an idea of how `NSArray` might do this (ignoring, for this example, that as a [class cluster](https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html), the actual implementation would be significantly more complicated):

下面是 `NSArray` 可能使用的解决方案（对于这个例子来说，我们暂时忽略掉 `NSArray` 实际上是一个[类簇](https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html)，真正的实现要比这个复杂得多）。

~~~{objective-c}
@implementation NSArray (Approximate)
- (BOOL)isEqualToArray:(NSArray *)array {
  if (!array || [self count] != [array count]) {
    return NO;
  }

  for (NSUInteger idx = 0; idx < [array count]; idx++) {
      if (![self[idx] isEqual:array[idx]]) {
          return NO;
      }
  }

  return YES;
}

- (BOOL)isEqual:(id)object {
  if (self == object) {
    return YES;
  }

  if (![object isKindOfClass:[NSArray class]]) {
    return NO;
  }

  return [self isEqualToArray:(NSArray *)object];
}
@end
~~~

The following `NSObject` subclasses in Foundation have custom equality implementations, with the corresponding method:

在 Foundation 框架中，下面这些 `NSObject` 的子类都有自己的相等性检查实现，分别使用下面这些方法：

- `NSAttributedString -isEqualToAttributedString:`
- `NSData -isEqualToData:`
- `NSDate -isEqualToDate:`
- `NSDictionary -isEqualToDictionary:`
- `NSHashTable -isEqualToHashTable:`
- `NSIndexSet -isEqualToIndexSet:`
- `NSNumber -isEqualToNumber:`
- `NSOrderedSet -isEqualToOrderedSet:`
- `NSSet -isEqualToSet:`
- `NSString -isEqualToString:`
- `NSTimeZone -isEqualToTimeZone:`
- `NSValue -isEqualToValue:`

When comparing two instances of any of these classes, one is encouraged to use these high-level methods rather than `isEqual:`.

对上面这些类来说，当需要对它们的两个实例进行比较时，推荐使用这些高层方法而不是直接使用 `isEqual:`。

However, our theoretical implementation is yet incomplete. Let's turn our attention now to `hash` (after a quick detour to clear something up about `NSString`:

到这里，我们理论的实现还没有完善，让我们把目光投向 `hash` 方法（不过首先我们要先通过一个小插曲，，解决一下 `NSString` 当中的一些问题）：

### The Curious Case of `NSString` Equality

### 古怪的 `NSString`

As an interesting aside, consider the following:

作为一个有意思的小插曲，我们看下面这个例子：

~~~{objective-c}
NSString *a = @"Hello";
NSString *b = @"Hello";
BOOL wtf = (a == b); // YES
~~~

Let it be perfectly clear that the correct way to compare `NSString` objects is to use `-isEqualToString:`. **Under no circumstances should you compare `NSString` with the `==` operator.**

首先我们要明确一点，比较 `NSString` 对象正确的方法是 `-isEqualToString:`。**在任何情况下都不要直接使用 `==` 来对 `NSString` 进行比较。**

So what's going on here? Why does this work, when the same code for `NSArray` or `NSDictionary` literals wouldn't work?

现在来看，到底发生了什么？为什么这样做结果是正确的，同样的代码对于 `NSArray` 和 `NSDictionary` 就不好使？

It all has to do with an optimization technique known as [string interning](http://en.wikipedia.org/wiki/String_interning), whereby one copy of immutable string value is copied for each distinct value. `NSString *a` and `*b` point to the same copy of the interned string value `@"Hello"`. _Note that this only works for statically defined immutable strings._

所有这些行为，都来源于一种称为[字符串驻留](http://en.wikipedia.org/wiki/String_interning)的优化技术，它把一个不可变字符串对象的值拷贝给各个不同的指针。`NSString *a` 和 `*b`都指向同样一个驻留字符串值 `@"Hello"`。 _注意所有这些针对的都是静态定义的不可变字符串。_

Interestingly enough, Objective-C selector names are also stored as interned strings in a shared string pool.

有意思的是，Objective-C 选择器的名字也是作为驻留字符串储存在一个共享的字符串池当中的。

`themoreyouknow.gif`.

## Hashing

## 散列

The primary use case of object equality tests for everyday object-oriented programming is to determine collection membership. To keep this fast, subclasses with custom equality implementations are expected to implement `hash` as well:

对于面向对象编程来说，对象相等性检查的主要用例，就是确定一个对象是不是一个集合的成员。为了加快这个过程，子类当中需要实现 `hash` 方法：

- Object equality is _commutative_ (`[a isEqual:b]` ⇒ `[b isEqual:a]`)
- 对象相等具有 _交换性_ （`[a isEqual:b]` ⇒ `[b isEqual:a]`)
- If objects are equal, then their `hash` values must also be equal (`[a isEqual:b]` ⇒ `[a hash] == [b hash]`)
- 如果两个对象相等，它们的 `hash` 值也一定是相等的 (`[a isEqual:b]` ⇒ `[a hash] == [b hash]`)
- However, the converse does not hold: two objects need not be equal in order for their hash values to be equal (`[a hash] == [b hash]` ¬⇒ `[a isEqual:b]`)
- 反过来则不然，两个对象的散列值相等不一定意味着它们就是相等的 (`[a hash] == [b hash]` ¬⇒ `[a isEqual:b]`)


Now for a quick flashback to Computer Science 101:

下面快速复习一下大学计算机基础：

---

A [hash table](http://en.wikipedia.org/wiki/Hash_table) is a fundamental data structure in programming, and it's what enables `NSSet` & `NSDictionary` to have fast (`O(1)`) lookup of elements.

[散列表](http://en.wikipedia.org/wiki/Hash_table)是程序设计中基础的数据结构之一，它使得 `NSSet` 和 `NSDictionary` 能够非常快速地(`O(1)`) 进行元素查找。


We can best understand hash tables by contrasting them to arrays:

**Arrays** store elements in sequential indexes, such that an Array of size `n` will have slots at positions `0`, `1`, up to `n - 1`. To determine where an element is stored in the array (if at all), each position would have to be checked one-by-one (unless the array happens to be sorted, but that's another story).

**Hash Tables** take a slightly different approach. Rather than storing elements sequentially (`0`, `1`, `...`, `n-1`), a hash table allocates `n` positions in memory, and uses a function to calculate a position within that range. A hash function is [deterministic](http://en.wikipedia.org/wiki/Deterministic_algorithm), and a _good_ hash function generates values in a relatively [uniform distribution](http://en.wikipedia.org/wiki/Uniform_distribution_%28discrete%29) without being too computationally expensive. A _hash collision_ occurs when two different objects calculate the same hash value. When this happens, the hash table will seek from the point of collision and place the new object in the first available place. As a hash table becomes more congested, the likelihood of collision increases, which leads to more time spent looking for a free space (hence why a hash function with a uniform distribution is so desireable).

---

One of the most common misconceptions about implementing a custom `hash` function comes from [affirming the consequent](http://en.wikipedia.org/wiki/Affirming_the_consequent), thinking that `hash` values _must_ be distinct. This often leads to [needlessly complicated implementations involving the magical incantation of prime numbers copied from Java textbooks](http://stackoverflow.com/a/254380/157142). In reality, a simple [`XOR`](http://en.wikipedia.org/wiki/Exclusive_or) over the hash values of critical properties is sufficient 99% of the time.

The trick is in thinking about what the critical value of an object is.

For an `NSDate`, the time interval since a reference date would be sufficient:

~~~{objective-c}
@implementation NSDate (Approximate)
- (NSUInteger)hash {
  return (NSUInteger)abs([self timeIntervalSinceReferenceDate]);
}
~~~

For a `UIColor`, a bit-shifted sum of RGB components is a convenient calculation:

~~~{objective-c}
@implementation UIColor (Approximate)
- (NSUInteger)hash {
  CGFloat red, green, blue;
  [self getRed:&red green:&green blue:&blue alpha:nil];
  return ((NSUInteger)(red * 255) << 16) + ((NSUInteger)(green * 255) << 8) + (NSUInteger)(blue * 255);
}
@end
~~~

## Implementing `-isEqual:` and `hash` in a Subclass

Bringing it all together, here's how one might override the default equality implementation in a subclass:

~~~{objective-c}
@interface Person
@property NSString *name;
@property NSDate *birthday;

- (BOOL)isEqualToPerson:(Person *)person;
@end

@implementation Person

- (BOOL)isEqualToPerson:(Person *)person {
  if (!person) {
    return NO;
  }

  BOOL haveEqualNames = (!self.name && !person.name) || [self.name isEqualToString:person.name];
  BOOL haveEqualBirthdays = (!self.birthday && !person.birthday) || [self.birthday isEqualToDate:person.birthday];

  return haveEqualNames && haveEqualBirthdays;
}

#pragma mark - NSObject

- (BOOL)isEqual:(id)object {
  if (self == object) {
    return YES;
  }

  if (![object isKindOfClass:[Person class]]) {
    return NO;
  }

  return [self isEqualToPerson:(Person *)object];
}

- (NSUInteger)hash {
  return [self.name hash] ^ [self.birthday hash];
}
~~~

> For the curious and pedantic, see [this post from Mike Ash](http://www.mikeash.com/pyblog/friday-qa-2010-06-18-implementing-equality-and-hashing.html) for an explanation of how `hash` implementations might be improved by bit-shifting or rotating composite values that may overlap.

## Don't Overthink It

While all of this has been an interesting exercise in epistemology and computer science, there is a lingering pragmatic detail:

**You don't usually need to implement this.**

There are many situations where the default identity check (two variables point to the same address in memory) is desirable behavior. This comes as a consequence of the limitations of data modeling.

Take, for instance, the previous example of the `Person` class. It's not inconceivable that two individuals would share a common name _and_ birthday. In reality, this crisis of identity would be resolved by additional information, whether it's a system-dependent identifier like a Social Security Number, their parents' identities, or any other physical attributes.

> Yet even that additional information is not entirely foolproof. After all, that person could be cloned, teleported, or whisked away into a parallel universe. Unlikely? Sure. But much of the challenge in modeling systems is dealing with imperfect assumptions. Just saying.

Ultimately, it's up to the abstraction to isolate the significant, identifying features that the system cares about, and disregard the rest. The developer can then decide whether objects will be used in such a way that set membership calculations should care about. In a program that only records `name` and `birthday`, it may perfectly correct to treat congruent instances as distinct entities.

---

Hopefully, after all of this explanation, we all stand with equal footing on this slippery subject.

As humans, we strive to understand and implement equality in our society and economy; in the laws and leaders that govern us; in the understanding that we extend to one another as we journey through existence. May we continue towards that ideal, where individuals are judged by the contents of their character, just as we judge a variable by the contents of its memory address.
